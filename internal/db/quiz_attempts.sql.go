// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: quiz_attempts.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createQuizAttempt = `-- name: CreateQuizAttempt :one
INSERT INTO quiz_attempts (quiz_id, user_id, start_time)
VALUES ($1, $2, NOW())
RETURNING id, quiz_id, user_id, score, start_time, end_time, created_at, updated_at
`

type CreateQuizAttemptParams struct {
	QuizID uuid.UUID `json:"quiz_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) CreateQuizAttempt(ctx context.Context, arg CreateQuizAttemptParams) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, createQuizAttempt, arg.QuizID, arg.UserID)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserID,
		&i.Score,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuizAttempt = `-- name: GetQuizAttempt :one
SELECT id, quiz_id, user_id, score, start_time, end_time, created_at, updated_at
FROM quiz_attempts
WHERE id = $1
`

func (q *Queries) GetQuizAttempt(ctx context.Context, id uuid.UUID) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, getQuizAttempt, id)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserID,
		&i.Score,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuizAttemptWithDetails = `-- name: GetQuizAttemptWithDetails :one
SELECT
    qa.id AS attempt_id,
    qa.quiz_id,
    qa.user_id,
    qa.score,
    qa.start_time,
    qa.end_time,
    q.title AS quiz_title,
    (SELECT COUNT(*) FROM questions WHERE quiz_id = qa.quiz_id) AS total_questions,
    (SELECT COUNT(*) FROM attempt_answers WHERE quiz_attempt_id = qa.id) AS answered_questions
FROM
    quiz_attempts qa
JOIN
    quizes q ON qa.quiz_id = q.id
WHERE
    qa.id = $1
`

type GetQuizAttemptWithDetailsRow struct {
	AttemptID         uuid.UUID          `json:"attempt_id"`
	QuizID            uuid.UUID          `json:"quiz_id"`
	UserID            uuid.UUID          `json:"user_id"`
	Score             pgtype.Int4        `json:"score"`
	StartTime         time.Time          `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
	QuizTitle         string             `json:"quiz_title"`
	TotalQuestions    int64              `json:"total_questions"`
	AnsweredQuestions int64              `json:"answered_questions"`
}

func (q *Queries) GetQuizAttemptWithDetails(ctx context.Context, id uuid.UUID) (GetQuizAttemptWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getQuizAttemptWithDetails, id)
	var i GetQuizAttemptWithDetailsRow
	err := row.Scan(
		&i.AttemptID,
		&i.QuizID,
		&i.UserID,
		&i.Score,
		&i.StartTime,
		&i.EndTime,
		&i.QuizTitle,
		&i.TotalQuestions,
		&i.AnsweredQuestions,
	)
	return i, err
}

const listQuizAttemptsByUser = `-- name: ListQuizAttemptsByUser :many
SELECT id, quiz_id, user_id, score, start_time, end_time, created_at, updated_at
FROM quiz_attempts
WHERE user_id = $1
ORDER BY start_time DESC
`

func (q *Queries) ListQuizAttemptsByUser(ctx context.Context, userID uuid.UUID) ([]QuizAttempt, error) {
	rows, err := q.db.Query(ctx, listQuizAttemptsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuizAttempt{}
	for rows.Next() {
		var i QuizAttempt
		if err := rows.Scan(
			&i.ID,
			&i.QuizID,
			&i.UserID,
			&i.Score,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuizAttemptsWithDetailsByUser = `-- name: ListQuizAttemptsWithDetailsByUser :many
SELECT
    qa.id AS attempt_id,
    qa.quiz_id,
    qa.user_id,
    qa.score,
    qa.start_time,
    qa.end_time,
    q.title AS quiz_title,
    (SELECT COUNT(*) FROM questions WHERE quiz_id = qa.quiz_id) AS total_questions,
    (SELECT COUNT(*) FROM attempt_answers WHERE quiz_attempt_id = qa.id) AS answered_questions
FROM
    quiz_attempts qa
JOIN
    quizes q ON qa.quiz_id = q.id
WHERE
    qa.user_id = $1
ORDER BY
    qa.start_time DESC
`

type ListQuizAttemptsWithDetailsByUserRow struct {
	AttemptID         uuid.UUID          `json:"attempt_id"`
	QuizID            uuid.UUID          `json:"quiz_id"`
	UserID            uuid.UUID          `json:"user_id"`
	Score             pgtype.Int4        `json:"score"`
	StartTime         time.Time          `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
	QuizTitle         string             `json:"quiz_title"`
	TotalQuestions    int64              `json:"total_questions"`
	AnsweredQuestions int64              `json:"answered_questions"`
}

func (q *Queries) ListQuizAttemptsWithDetailsByUser(ctx context.Context, userID uuid.UUID) ([]ListQuizAttemptsWithDetailsByUserRow, error) {
	rows, err := q.db.Query(ctx, listQuizAttemptsWithDetailsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQuizAttemptsWithDetailsByUserRow{}
	for rows.Next() {
		var i ListQuizAttemptsWithDetailsByUserRow
		if err := rows.Scan(
			&i.AttemptID,
			&i.QuizID,
			&i.UserID,
			&i.Score,
			&i.StartTime,
			&i.EndTime,
			&i.QuizTitle,
			&i.TotalQuestions,
			&i.AnsweredQuestions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAttemptsWithQuizName = `-- name: ListUserAttemptsWithQuizName :many
SELECT
    qa.id AS attempt_id,
    qa.quiz_id, -- Added quiz_id
    qa.start_time,
    qa.score,
    q.title AS quiz_name,
    (SELECT COUNT(*) FROM questions WHERE quiz_id = q.id) AS total_questions -- Added total questions
FROM
    quiz_attempts qa
JOIN
    quizes q ON qa.quiz_id = q.id
WHERE
    qa.user_id = $1
ORDER BY
    qa.start_time DESC
`

type ListUserAttemptsWithQuizNameRow struct {
	AttemptID      uuid.UUID   `json:"attempt_id"`
	QuizID         uuid.UUID   `json:"quiz_id"`
	StartTime      time.Time   `json:"start_time"`
	Score          pgtype.Int4 `json:"score"`
	QuizName       string      `json:"quiz_name"`
	TotalQuestions int64       `json:"total_questions"`
}

func (q *Queries) ListUserAttemptsWithQuizName(ctx context.Context, userID uuid.UUID) ([]ListUserAttemptsWithQuizNameRow, error) {
	rows, err := q.db.Query(ctx, listUserAttemptsWithQuizName, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserAttemptsWithQuizNameRow{}
	for rows.Next() {
		var i ListUserAttemptsWithQuizNameRow
		if err := rows.Scan(
			&i.AttemptID,
			&i.QuizID,
			&i.StartTime,
			&i.Score,
			&i.QuizName,
			&i.TotalQuestions,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuizAttemptScoreAndEndTime = `-- name: UpdateQuizAttemptScoreAndEndTime :one
UPDATE quiz_attempts
SET score = $2, end_time = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, quiz_id, user_id, score, start_time, end_time, created_at, updated_at
`

type UpdateQuizAttemptScoreAndEndTimeParams struct {
	ID      uuid.UUID          `json:"id"`
	Score   pgtype.Int4        `json:"score"`
	EndTime pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) UpdateQuizAttemptScoreAndEndTime(ctx context.Context, arg UpdateQuizAttemptScoreAndEndTimeParams) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, updateQuizAttemptScoreAndEndTime, arg.ID, arg.Score, arg.EndTime)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserID,
		&i.Score,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
