// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: answers.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAnswer = `-- name: CreateAnswer :one
INSERT INTO answers (
    question_id, answer, is_correct, explanation
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, question_id, answer, is_correct, explanation, created_at, updated_at
`

type CreateAnswerParams struct {
	QuestionID  uuid.UUID   `json:"question_id"`
	Answer      string      `json:"answer"`
	IsCorrect   bool        `json:"is_correct"`
	Explanation pgtype.Text `json:"explanation"`
}

func (q *Queries) CreateAnswer(ctx context.Context, arg CreateAnswerParams) (Answer, error) {
	row := q.db.QueryRow(ctx, createAnswer,
		arg.QuestionID,
		arg.Answer,
		arg.IsCorrect,
		arg.Explanation,
	)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.Answer,
		&i.IsCorrect,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAnswer = `-- name: DeleteAnswer :exec
DELETE FROM answers
WHERE id = $1
`

func (q *Queries) DeleteAnswer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAnswer, id)
	return err
}

const deleteAnswersByQuestionID = `-- name: DeleteAnswersByQuestionID :exec
DELETE FROM answers
WHERE question_id = $1
`

func (q *Queries) DeleteAnswersByQuestionID(ctx context.Context, questionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAnswersByQuestionID, questionID)
	return err
}

const getAnswerByID = `-- name: GetAnswerByID :one
SELECT id, question_id, answer, is_correct, explanation, created_at, updated_at FROM answers
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAnswerByID(ctx context.Context, id uuid.UUID) (Answer, error) {
	row := q.db.QueryRow(ctx, getAnswerByID, id)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.Answer,
		&i.IsCorrect,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnswerCorrectness = `-- name: GetAnswerCorrectness :one
SELECT is_correct
FROM answers
WHERE id = $1
`

func (q *Queries) GetAnswerCorrectness(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, getAnswerCorrectness, id)
	var is_correct bool
	err := row.Scan(&is_correct)
	return is_correct, err
}

const listAnswers = `-- name: ListAnswers :many
SELECT id, question_id, answer, is_correct, explanation, created_at, updated_at FROM answers
ORDER BY created_at ASC
`

func (q *Queries) ListAnswers(ctx context.Context) ([]Answer, error) {
	rows, err := q.db.Query(ctx, listAnswers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Answer{}
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.Answer,
			&i.IsCorrect,
			&i.Explanation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnswersByQuestionID = `-- name: ListAnswersByQuestionID :many
SELECT id, question_id, answer, is_correct, explanation, created_at, updated_at FROM answers
WHERE question_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListAnswersByQuestionID(ctx context.Context, questionID uuid.UUID) ([]Answer, error) {
	rows, err := q.db.Query(ctx, listAnswersByQuestionID, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Answer{}
	for rows.Next() {
		var i Answer
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.Answer,
			&i.IsCorrect,
			&i.Explanation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnswer = `-- name: UpdateAnswer :one

UPDATE answers
SET
    question_id = $2,
    answer = $3,
    is_correct = $4,
    explanation = $5
WHERE id = $1
RETURNING id, question_id, answer, is_correct, explanation, created_at, updated_at
`

type UpdateAnswerParams struct {
	ID          uuid.UUID   `json:"id"`
	QuestionID  uuid.UUID   `json:"question_id"`
	Answer      string      `json:"answer"`
	IsCorrect   bool        `json:"is_correct"`
	Explanation pgtype.Text `json:"explanation"`
}

// Or some other defined order
func (q *Queries) UpdateAnswer(ctx context.Context, arg UpdateAnswerParams) (Answer, error) {
	row := q.db.QueryRow(ctx, updateAnswer,
		arg.ID,
		arg.QuestionID,
		arg.Answer,
		arg.IsCorrect,
		arg.Explanation,
	)
	var i Answer
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.Answer,
		&i.IsCorrect,
		&i.Explanation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
